{"meta":{"title":"Dragonchu","subtitle":"","description":"","author":"Dragonchu","url":"https://dragonchu.github.io","root":"/"},"pages":[{"title":"about","date":"2021-06-13T07:40:27.000Z","updated":"2021-06-13T08:01:34.910Z","comments":true,"path":"about/index.html","permalink":"https://dragonchu.github.io/about/index.html","excerpt":"","text":""},{"title":"schedule","date":"2021-06-13T08:07:07.000Z","updated":"2021-06-13T08:08:38.380Z","comments":true,"path":"schedule/index.html","permalink":"https://dragonchu.github.io/schedule/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-06-13T07:40:14.000Z","updated":"2021-06-13T08:02:04.855Z","comments":true,"path":"tags/index.html","permalink":"https://dragonchu.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-06-13T07:39:31.000Z","updated":"2021-06-13T07:55:54.712Z","comments":true,"path":"categories/index.html","permalink":"https://dragonchu.github.io/categories/index.html","excerpt":"","text":""},{"title":"archive","date":"2021-06-13T10:49:15.000Z","updated":"2021-06-13T10:54:51.240Z","comments":true,"path":"archive/index.html","permalink":"https://dragonchu.github.io/archive/index.html","excerpt":"","text":""}],"posts":[{"title":"TCP为什么使用三次握手协议","slug":"TCP为什么使用三次握手协议","date":"2021-05-09T14:40:52.000Z","updated":"2021-05-09T14:43:41.627Z","comments":true,"path":"2021/05/09/TCP为什么使用三次握手协议/","link":"","permalink":"https://dragonchu.github.io/2021/05/09/TCP%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"TCP为什么使用三次握手协议日期：2021年05月09日 背景知识TCP是一个高可靠的主机到主机之间的通讯协议，这些主机位于分组交换网络（基于IP协议）中，也可能位于由这些网络组成的通讯系统中。TCP需要在不可靠的网络通讯系统中提供可靠的服务必须满足一系列基本实现，其中包括可靠性和多路复用。 为了实现可靠性，TCP连接发送的每个字节都有一个序列号。因为每个字节都编号了，所以可以对每个字节进行确认。 为了实现多路复用，TCP提供了一系列端口，主机地址加上端口号称为socket。TCP协议没有限制同一个TCP连接的重复使用。一个连接由一对socket唯一确定。 使用三次握手的充分性如果一条连接突然断开重连后，TCP 如何识别旧连接发送的包？为了避免混乱，我们要避免当前连接正在使用的序列号与旧连接发送的且仍在网络中传输的数据包的序列号相同。并且要在TCP协议无法记住以前的序列号的前提下实现这个功能（因为TCP可能崩溃并忘记之前的序列号）。 为了实现上述功能，可以使用ISN生成器。当一个新连接建立时，初始序列号（ initial sequence number ISN）生成器会生成一个新的32位的 ISN。ISN生成器生成的初始序列号是唯一的。 每一个连接都有一个接收序列号和发送序列号。发送初始序列号由发送数据的TCP实体选择，接收序列号是在连接建立时确定的。 连接建立时，两端必须要同步对方的初始序列号。双方通过同步带有SYN标志和初始序列号的数据段来实现。所以为了实现上述目的，一般需要一个初始化序列号选择器并且需要一些握手机制来同步初始化序列号。 同步机制需要发送自己的初始化序列号给对方，并且接收对方发送过来的确认信息。连接的两端必须接收对方发送过来的初始序列号并且发回确认信息。 A --&gt; B SYN my sequence number is X A &lt;-- B ACK your sequence number is X A &lt;-- B SYN my sequence number is Y A --&gt; B ACK your sequence number is Y 因为第二步和第三步可以合并成一步，所以一般称为三次握手 the three way (or three message) handshake。 因为序列号并没有使用一个网络里的全局时钟来进行同步，而且不同 TCP实体会使用不同的机制来选择初始序列号。当一端接收到一个SYN连接请求时，无法确定这个连接请求是不是之前被网络延迟的连接请求（如果是之前的连接请求，应该拒绝连接），所必须向另一端确认这个序列号。所以三次握手是必须的。 使用三次握手的必要性三次握手可以确保过期的连接请求即使重新送到了接收端也会被接收端抛弃。因为接收端每次接收到连接请求都会向发送方进行确认，而因为不会出现相同的序列号，所以接收端接受的这个过期的连接请求的序列号一定与发送方的初始序列号不同，所以这个过期的连接请求一定会被拒绝。 三次握手可以确保两端进行可靠的数据传输。因为连接时两端都知道对方的初始序列号，所以接下来的传输过程双方对整个传输过程的序列号都是完全掌握的。 参考资料：https://datatracker.ietf.org/doc/html/rfc793 https://book.douban.com/subject/10510747/（6.2.2节）","categories":[],"tags":[]},{"title":"OpenCV的安装与环境配置","slug":"OpenCV的安装与环境配置","date":"2021-04-23T07:30:49.000Z","updated":"2021-04-23T07:31:49.765Z","comments":true,"path":"2021/04/23/OpenCV的安装与环境配置/","link":"","permalink":"https://dragonchu.github.io/2021/04/23/OpenCV%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","excerpt":"","text":"OpenCV的安装与环境配置（window10，Visual Studio 2019）日期：2021年04月17日 OpenCV的安装第一步：下载OpenCv https://opencv.org/releases/，本文使用 OpenCV-4.5.0 。 第二步：下载得到 opencv-4.5.0-vc14_vc15.exe 文件，运行该文件，选择解压到目标地址，本文解压到目录 D:\\Library 。 第三步：为了方便以及清晰，这一步添加系统环境变量 OPENCV_DIR 。方法为以管理员身份运行 cmd ，输入并运行命令 setx -m OPENCV_DIR D:\\Library\\opencv\\build\\x64\\vc15，（此处根据平台环境可能需要有所调整）。 第四步：添加系统环境变量Path中的环境变量，添加**%OPENCV_DIR%\\bin** Visual Studio 2019项目的配置 解决方案配置为 Debug ，解决方案平台为 x64 。 项目属性 - VC++ 目录 - 包含目录，添加 D:\\Library\\opencv\\build\\include 路径 项目属性 - VC++ 目录 - 库目录，添加 D:\\Library\\opencv\\build\\x64\\vc15\\lib 路径 项目属性 - 链接器 - 输入 - 附加依赖项，添加 opencv_world450d.lib ，（此处lib文件可在 D:\\Library\\opencv\\build\\x64\\vc15\\bin 中查看，d表示debug，解决方案与平台需要根据实际情况做调整） 测试程序#include &lt;iostream&gt; #include &lt;stdio.h&gt; #include &quot;opencv2&#x2F;highgui&#x2F;highgui.hpp&quot; #include &quot;opencv2&#x2F;imgproc&#x2F;imgproc.hpp&quot; using namespace std; using namespace cv; int main() &#123; &#x2F;&#x2F; 设置窗口 Mat img &#x3D; Mat::zeros(Size(800, 600), CV_8UC3); img.setTo(255); &#x2F;&#x2F; 设置屏幕为白色 Point p1(100, 100); &#x2F;&#x2F; 点p1 Point p2(758, 50); &#x2F;&#x2F; 点p2 &#x2F;&#x2F; 画直线函数 line(img, p1, p2, Scalar(0, 0, 255), 2); &#x2F;&#x2F; 红色 line(img, Point(300, 300), Point(758, 400), Scalar(0, 255, 255), 3); Point p(20, 20);&#x2F;&#x2F;初始化点坐标为(20,20) circle(img, p, 1, Scalar(0, 255, 0), -1); &#x2F;&#x2F; 画半径为1的圆(画点） Point p4; p4.x &#x3D; 300; p4.y &#x3D; 300; circle(img, p4, 100, Scalar(120, 120, 120), -1); int thickness &#x3D; 3; int lineType &#x3D; 8; double angle &#x3D; 30; &#x2F;&#x2F;椭圆旋转角度 ellipse(img, Point(100, 100), Size(90, 60), angle, 0, 360, Scalar(255, 255, 0), thickness, lineType); &#x2F;&#x2F; 画矩形 Rect r(250, 250, 120, 200); rectangle(img, r, Scalar(0, 255, 255), 3); imshow(&quot;画板&quot;, img); waitKey(); return 0; &#125;","categories":[],"tags":[]}],"categories":[],"tags":[]}